:))=========================
26 august 2019
========================
#include <bits/stdc++.h>

using namespace std;

int main(){
    ifstream fin("bac.txt");
    int a[101]={0};
    int x;
    while(fin >> x){
        a[x]++;
    }
    for(int i = 1; i<=100; i+=2)
        while(a[i]--)
            cout << i << " ";
    for(int i = 0; i<=100; i+=2)
        while(a[i]--)
            cout << i << " ";

    return 0;
}
======================================
4 iulie 2019
======================================
#include <bits/stdc++.h>

using namespace std;

int main(){
    ifstream fin("bac.txt");
    int ma[101]={0};
    bool test = 0;
    int varf=-1;
    int x;
    while(fin >> x){
        if(x==varf && test == 1)
        {
            cout << x << " ";
            continue;
        }

        if(varf>x)
            test = 0;

        if(x>varf && ma[x]==0){
            varf = x;
            cout << x << " ";
            ma[x]=1;
            test = 1;
            continue;
        }

    }
    return 0;
}
=====================================
sesiune speciala 2019
=====================================
include <bits/stdc++.h>

using namespace std;

int main(){
    int v[1001];
    int n;
    cin >> n;
    cin >> v[1] >> v[2] >> v[3];
    for(int i = 4; i<=n; ++i)
        v[i] = v[i-1] + v[i-2] - v[i-3];
    for(int i = n; i>=1; --i)
        cout << v[i] << " ";
    return 0;
}
================================
simulare 2019
=============================
#include <bits/stdc++.h>

using namespace std;

int main(){
    ifstream fin("bac.txt");
    int n;
    fin >> n;
    int x;
    int par1=-1, imp1=-1, par2=100000, imp2=100000;
    while(n--){
        fin >> x;
        if(x%2==0 && par1 < x)
            par1=x;
        if(x%2==1 && imp1 < x)
            imp1 = x;
    }
    while(fin >> x){
        if(x%2==0 && par2 > x)
            par2=x;
        if(x%2==1 && imp2 > x)
            imp2 = x;
    }
    if(par1 < imp2 && imp1 < par2)
        cout << "DA";
    else
        cout << "NU";
    return 0;
}


================================================================
AZI :)

intrebare: https://modinfo.ro/admitere/buc/2022/Grile_21mai2022_enunturi.pdf --> problema 11
Cate numere din intervalul 1, 2.000.000.000 au exact 5 divizori
x^4 - x numar prim
am calculat radical de ordin 4 din 2.000.000.000 - > 211 numere si trebuie sa aleg numerele prime mai mici decat 211


http://www.cs.ubbcluj.ro/wp-content/uploads/subiect-informatica-concurs-mate-info-ubb-ro-2018.pdf
conversie ->
void convsersie(char s[], int indice, int $nr){
	if(s[indice]==NULL)
		return;
	if(s[indice]>='A'){
		nr = nr*16  +s[i] - 'A' + 10;
		conversie(s, ++indice, nr);
}
	else{
		nr = nr * 16 + s[i] - '0';
		conversie(s, ++indice, nr);
}
}


#include <cstring>
#include <iostream>
using namespace std;
int conversie(char s[], int lung) {
  if (lung == 0)
    return 0;
  else {
    int nr = conversie(s, lung - 1);
    int cod;
    if (s[lung - 1] >= 'A')
      cod = s[lung - 1] - 'A' + 10;
    else
      cod = s[lung - 1] - '0';
    return nr * 16 + cod;
  }
}
int main() {
  char s[] = "12A";

  cout << conversie(s, 3);
}


"72A"-->"72"->"7"->""
               10
        
7
7*16+2
cod=10, (7*16+2)*16+10

nr=7
nr=7*16+2
nr=(7*16+2)*16+10

nr=

APLICATII ALE DESCOMPUNERII IN FACTORI PRIMI
3^4: 1,3,3^2,3^3

n=f1^p1 * f2^p2 *....*fk^pk
d=f1^e1 * f2^e2 *....*fk^ek, ei: 0,1,2...pi

n=2^ 2* 5^2
d=2^ * 5^
nrdiv(n)=(p1+1)*(p2+1)...*(pk+1)

5=5*1
n=f^4 
pow(200000000,1/4);
211: 2,3,...
---------------------
d=2;
while(x>1)
{ p=0;
  while(x%d==0) x/=d,p++;
  !!! prod=prod*(p+1);
  d++;
}  nr de divizori al numarului n
-----------------------
d=2;
while(x>1)
{ p=0;p1=1
  while(x%d==0) x/=d,p++,p1=p1*d;
  !!! prod=prod*(p1*d-1)/(d-1);
  d++;
}  suma divizorilor numarului n

======================
d=2;produs=n;
while(x>1)
{ p=0;
  while(x%d==0) x/=d,p++;
  if(p) produs=produs*(d-1)/d;
  d++;
}  INDICATORUL LUI EULER=nr de numere <=n , prime cu n
------------------------------

pbinfo--nrperechi
n=360
Cate perechi de numere (a,b) au prop ca [a,b]=360 ????(cmmmc)

----------------
CULEGERE CARMEN POPESCU
POZA 1
#include <cmath>
#include <iostream>
#include <iomanip>
using namespace std;

double radical(int x){
  double epsi = 0.0001;
  double aux = 1;
  double aux2 = (aux + x/aux)/2;
  while(abs(aux-aux2)>=epsi){
    aux = aux2;
    aux2 = (aux + x/aux)/2;
  }
  return aux2;
}

int main() {
  cout << sqrt(7) << endl;
  cout << fixed<<setprecision(3)<<radical(7);
}

POZA 2


1,  1,2,  1,2,3  ....poz n eficient???

1/1 | 1/2 2/1 | 3/1 2/2 1/3 |1/4 2/3...
                                  poz=2
....poz n?? 
| 
n=8


#include <cmath>
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
  int n, k=0,d=0,poz,p,q;
  int l = 1;
  int suma = 0;
  cin >> n>>p>>q;
  while(n > suma)
    k++,suma+=k;
  poz=n-(suma-k);
  if(k%2==0)
    cout << poz << " " << k+1-poz;
  else
    cout << k+1-poz << " " << poz;
	
  }//punctul b) de rezolvat!!

TEMA- poze+
https://profs.info.uaic.ro/~vcosmin/pagini/resurse_pregatire/variante-bac-2009-informatica-intensiv.pdf

din variante 1-30 selectati problemele de eficienta care nu au fost facute pana acum!!!
(cele mai grele, va rog)


