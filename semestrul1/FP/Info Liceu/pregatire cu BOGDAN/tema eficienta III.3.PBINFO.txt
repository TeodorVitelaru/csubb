===================
SUBIECTE BAC PBINFO
===================



BAC 2022 AUGUST
a)
#include <bits/stdc++.h>
using namespace std;
ifstream fin ("bac.txt");
int main()
{
  int x, lmax=0, i=1, aparitii=0;
  fin>>x;
  int copie=x;
      while(fin>>x)
        {
           if(x%2==copie%2)
            i++;
          else
            {
            
              i=1; copie=x;
            }
            if(lmax<i)
               {lmax=i; aparitii=1;}
             else
               if(lmax==i)
                aparitii++;
      }
  cout<<aparitii<<" "<<lmax;

  return 0;
}
b)
Algoritmul utilizat verifica paritatea fiecarui numar citit si retine lungimea maxima a secentelor paritare. Algoritmul este eficient din punct de vedere al timpului de executarem efectuandu se un numar de pasi egal cu cel al numerelor citite, iar ca memorie s au folosit variabilele necesare rezolvarii problemei (lmax, i, x, aparitii) plus o copie a primului numar dintr o secventa paritare.

================================================================


BAC 2022 IUNIE
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin ("bac.txt");
int main()
{
  int x, y, n, m, i=0;
  fin>>x>>y;
  fin>>m;
  while(fin>>n)
    {
      if(m>=x && m<=y && n!=m)
        i++;
      m=n;
    }
    cout<<i;
  return 0;
}
a)
Algoritmul utilizat verifica daca numerele din interval sunt distincte si afiseaza cate sunt. Metoda folosita este eficienta din punct de vedere al memoriei, efectuandu se in y pasi, iar ca memorie s au folosit 5 variabile(x,y-capetele intervalului, m,n-numerele consecutive citite, i-numarul de aparitii).

=====================================================================


BAC 2022 MAI
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin ("bac.txt");
int main()
{
  int lmax=0, x, y, i=0;
  fin>>x;
  while(fin>>y)
   if(x==y)
   {
     int cnt=x-2;
     while(cnt>0)
       {fin>>y; cnt--;
         if(x!=y) cnt=-1;}
     if(cnt!=-1)
     {i=i+x; fin>>x;
       if(lmax<i)
         lmax=i;}
     else
     {x=y; i=0;}
     }
   else
      if(x==1)
      {i=1; x=y;}
   else
      {x=y; i=0;}
  
  cout<<lmax;
  return 0;
}
a)
Algoritmul proiectat citeste cate un numar si verifica daca apare de un numar egal cu valoarea sa, urmand sa calculeze lungimea maxima a subsirului cu proprietatile de mai sus. Algoritmul este eficient ca timp, efectuandu se un nr de pasi egal cu cel al numerelor date, iar ca memorie s au utilizat 6 variabile(lmax-lungimea maxima a subsirului cu proprietatile; x,y-numerel din sir; cnt-contor de verificare a conditie). 

===================================================================


BAC 2022 
b)
#include <bits/stdc++.h>
using namespace std;
ofstream fout ("bac.txt");

int main()
{
  int p=1, p3=0, n;
  cin>>n;
  while(3*p<=n)
    {
      p*=3;
      p3+=n/p;
    }
  cout<<p3/2;

    return 0;
}
a)
Pentru numarul 45, in produsul n!, mai rar apar multiplii lui 5 decat cei ai lui 3. Algoritmul proiectat calculeaza putearea la care apare 45 in produsul 45! prin rezolvarea sumei n/5+n/5^2+...+n/5^p5. Metoda folosita este eficienta deoarece rezultatul se efectueaza in log5n pasi, iar ca memorie sunt utilizate doar 3 variabile (p, p5, n).

========================================================================


BAC 2021 AUGUST
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin ("numere.in");
ofstream fout ("numere.out");

int main()
{
  int a[11][11]={0}, x, na, nb, perechi=0, y;
  fin>>na>>nb;
  for(int i=1; i<=na; ++i)
    {
      fin>>x;
      if(x%10!=x%100/10)
      {a[x%10][x%100/10]++;
      a[x%100/10][x%10]++;}
      else
        a[x%10][x%100/10]++;
        
    }
  for(int i=1; i<=nb; ++i)
    {
      fin>>y;
      if(a[y%10][y%100/10]!=0)
        perechi+=a[y%10][y%100/10];
    }
  fout<<perechi;
    return 0;
}
a)
Algoritmul utilizat retine intr o matrice patratica aparitia ultimelor doua cifre din A (linia=cifra zecilor/unitatilor, coloana=cifra unitatilor/zecilor) si intr o variabila perechi numarul perechilor pe care le poate forma cu termenii din B. Algorimul este eficinet din punct dde vedere al timpului de executie deoarece se vor citi o singura data temenii din A si in acelasi timp se va retine aparitia ultimelor doua cifre, iar termenii din B tot o data vor fi cititi si se va calcula odata cu citirea lor nr de posibile perechi.

===========================================================================


BAC 2021 IUNIE  gresesc undeva
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin ("bac.txt");

int main()
{
  int x, n, p=1, n1=0, n2=0, aux;
  bool ok=false, cont=false;
  fin>>x;
  int copie=x;
  
  while(x>0)
    {p*=10; x/=10;}
  
  while(fin>>n)
      if(n%p==copie)
      {
        if(!ok)
        {aux=n1+1; n1=n; ok=true;}
        else
          if(ok && aux==n1+1)
        { n2=n; aux=aux-1;}
        else
            if(ok && aux==n1)
            {n1=n2; n2=n;}
      }
      else
      {ok=false;}

  if(aux%p!=copie)
    cout<<aux-1<<" "<<n2;
  else
   cout<<n1<<" "<<n2;
  
    return 0;
}
a)


===========================================================================


BAC 2021 MAI
b)
#include <bits/stdc++.h>
using namespace std;


int main()
{
  int x, y;
  cin>>x>>y;
  cout<<y<<" "<<x<<" ";
  int n=(y-x)/2;
  for(int i=n-1; i>=1; i--)
    {x=x-2*i; cout<<x<<" ";}
  
    return 0;
}
a)
Algoritmul utilizat calculeaza in variabila n ratia progresiei de mai sus, reprezentant si numarul de termeni afisati plus 1. Metoda folosita este eficienta ca timp deoarece se efectueaza in (y-x)/2-1 pasi, depizand, astfel, de cele doua numere citite de la tastatura, iar ca memorie s au folosit doar 3 variabile (x,y-numerele date de problema, n-ratia progresiei). 

==========================================================================


BAC 2021 MARTIE
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac.in");

int main()
{
  int used[11]={0}, x, nr=0;
  while(fin>>x)
    if(!used[x])
    {nr=nr+10+x*x; used[x]=1;}
  else
      nr=nr+x*x;
  cout<<nr;
  
    return 0;
}
a)
Algoritmul contine un vector care ajuta la verificarea modelelor diferite si calculeaza pretul total. Metoda folosita este eficienta din punct de vedere al timpului de executare deoarecce odata cu citirea elementelor din fisier, se calculeaza si pretul necar, numarul de pasi depinzand de numarul de termeni din "bac.in".

=============================================================================




=========================
TESTE DE ANTRENAMENT 2021
=========================


TESTUL 1
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac.txt");

int main()
{
  int x, v[101]={0}, cnt=0, a=0, b=0;
  while(fin>>x)
      if(x>=10 && x<=99)
        v[x]++;
  for(int i=98; i>=10; i--)
    if(i%10!=i/10 && v[i]==0)
				if(a==0)
           a=i; 
				else
        {b=i;cout<<a<<" "<<b; return 0;}
  cout<<"nu exista";
   
    return 0;
}

===============================================================================



TESTUL 2
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac.in");

int main()
{
  int ok1=0, ok2=0, x, i=0;
  while(fin>>x)
    {
      i++;
      if(x>0 && ok1==0)
        ok1=i;
      else
        if(x>0)
          ok2=i;
    }
  if(i-ok1+1>=ok2)
    cout<<i-ok1+1;
  else
    cout<<ok2;
    return 0;
}
a)
Algoritmul utilizat retine primul si ultimul numar pozitiv din sir si afiseaza lungimea sirului mai lung care incepe sau se termina cu un numar pozitiv. Metoda utilizata este eficineta deoarece odata cu citirea elementelor din fisier se retine pozitia primului, precum si a ultimului element pozitiv, iar ca memorie s au utilizat 4 variabile(x- nr citi din fisier, ok1,ok2-numerele pozitive cautate, i-contor pentru numarul elementelor).

=================================================================================


TESTUL 3
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac.in");

int main()
{
  int a=0, b=0, i=0, used[11]={0}, x, maxi=0;
  while(fin>>x)
    {
      i++;
      int cif=(x%100)/10;
        used[cif]++;
       if(maxi<=used[cif] && used[cif]!=0)
       {maxi=used[cif]; a=b; b=i;}
    }
  cout<<a<<" "<<b;
    return 0;
}
a)
Algoritmul utilizat foloseste un vector de frecventa used[], in care se stocheaza numarul de aparitii a fiecarei cifre a zecilor dintr un numar, iar variabila maxi retine numatul maxim de aceste aparitii. Metoda folosita este eficienta din punct de vedere al timpului de executare deoarece, odata cu citirea numerelor din fisier, se retine pozitita elementelor precedatu de un numar maxim de valori z-prietene cu ei.

==================================================================================


TESTUL 4 
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac1.in");
ifstream gin("bac2.in");

int main()
{
  int n1, n2, x, y, i=1, j=1;
  fin>>n1>>x; 
  gin>>n2>>y;
  
  while(i<=n1 && j<=n2)
    {
        if(x<y)
        {if(x%5==0)
          cout<<x<<" ";
          fin>>x; i++;}
       else
          if(y<x)
          {if(y%5==0)
              cout<<y<<" ";
            gin>>y; j++;}
       else
          {i++; j++; fin>>x; gin>>y;}
    }
  while(i<=n1)
    {
      if(x%5==0)
         cout<<x<<" ";
      fin>>x; i++;
    }
   while(j<=n2)
    {
      if(y%5==0)
      cout<<y<<" ";
      gin>>y; j++;
    }
    return 0;
}
a)

==================================================================================


TESTUL 5
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac.txt");


int main()
{
  int maxi, x, n;
  fin>>n>>x;
  maxi=x;
  cout<<x<<" ";
  for(int i=2; i<=n; ++i)
    {
      fin>>x;
      if(maxi<x)
       maxi=x;
      cout<<maxi<<" ";
    }
    
    return 0;
}
a)
Algoritmul utilizat retine in variabila maxi maximul a i termeni pentru i de la 1 la n si o afiseaza. Metoda utilizata este eficienta din punct de vedere al timpului de executare deoarece rezultatul este determinat in n pasi, iar ca memorie s au folosit 3 variabile (n-nr de elemente, x-termenul din sir, maxi-maximul a i elemente).

=====================================================================================


TESTUL 6 
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac.in");


int main()
{
  int i=0, x, n1=0, n2=0, n3=0;
  while(fin>>x)
    {
      i++;
      if(x<0 && n1==0)
        n1=i;
      else
        if(x<0 && n2==0)
           n2=i;
      else
          if(x<0 && n3==0)
           n3=i;
    }
  cout<<max(max(n2-1, n3-n2-1), i-n2);
    
    return 0;
}
========================================================================================


TESTUL 7
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac.in");


int main()
{
  int x;
  while(fin>>x)
    if(x%2==0)
      cout<<x<<" ";
    
    return 0;
}

=========================================================================================


TESTUL 8
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac.txt");


int main()
{
  int x, a=0, b=0;
  while(fin>>x)
      if(x%2==1)
      {a=b; b=x;}
  if(a==0)
    cout<<"nu exista";
  else
   cout<<a<<" "<<b;
    
    return 0;
}

========================================================================================


TESTUL 9 
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("numere.txt");


int main()
{
  int x, v[11]={0};
  long long  nr=0;
  while(fin>>x)
    while(x)
      {v[x%10]++; x/=10;}
  for(int i=9; i>=0; i--)
    while(v[i]>0)
      {cout<<i; v[i]--;}
  cout<<nr;
  
    return 0;
}

===========================================================================================


TESTUL 10
b)
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac.txt");

int main()
{
  int x, nr=1, n;
  fin>>n;
  while(fin>>x)
    if(x<n)
      nr++;
  cout<<nr;
  
    return 0;
}
a)
Algoritmul utilizat retine primul numar si memoreaza in variabila nr cate numere din fisier sunt mai mici decat primul si o afiseaza. Metoda utilizata este eficienta ca timp de executare deoarece odata cu citirea elementelor se determina pozitia pe care ar ocupa-o intr un sir format din acelasi valori, ordonat crescator, avand un numar de n pasi. Eficienta algoritmului ca memorie utilizata este data de cele 3 variabile nr intregi (x-termenii din sir, n-primul termen, nr-pozitia afisata).

==============================================================================================


TESTUL 11
repetare cu III.3./mai 2021
===========================================================================================


TESTUL 12
identic cu 10!
==========================================================================================






==========================
concurs ubb septembrie 2022
===========================
3.pe foaie este ce trebuie, dar in program nu
#include <bits/stdc++.h>
using namespace std;
ifstream fin("bac.in");
int u, p;
int f(int n)
{
  if(n<10)
    return n;
  u=n%10;
  p=f(n/10);
  if(u%5<=p%5)
    return u;
  else
    return p;
}
int main()
{
 int n;
  cin>>n;
  cout<<f(n);
  return 0;
}
  

