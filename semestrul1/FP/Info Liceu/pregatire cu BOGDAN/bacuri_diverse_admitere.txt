SIRURI cu subsiruri

val:1, 1,2, 1,2,3  1,2,3,4          1 2      k
poz:1    3      6        10     15      n=20
pozr=5

poz=0;k=0;
while(poz<n)
{ k++;
  poz=poz+k;
}
//poz>=n
pozr=n-k*(k-1)/2;
cout<<pozr;
---

n===k(k+1)/2---> k===sqrt(2n)----> O(sqrt(n))


Solutia O(1)  (cmath<-- sqrt())

1+2+...+k=n
k^2+k-2*n=0---> k=(int)(-1+sqrt(delta))/2);
delta=1+8*n;

n=10-->k=4
n=12---> k++;


cin>>n;delta=1+8*n;
double rad=sqrt(delta);
if(rad==(int)rad)
  k=(-1+rad)/2;
else
 k=(int)(1+rad)/2;
cout<<n-k*(k-1)/2;
-----
==========================
1, 2,2, 3,3,3,....
1, 1,2,1, 1,2,3,2,1, 
1, 2,1, 3,2,1  4,3,2,1
1,  1,2,2  1,2,3,3,3      1,2,3...k,k...k
================
#include <bits/stdc++.h>

using namespace std;
int putere(int x){
    int p = 0;
    while(x!=1){
        p++;
        x/=2;
    }
    return p;
}
int main()
{
    int n;
    int x;
    int v[10]={0};
    ifstream fin("bac.txt");
    fin >> n;
    int cnt = 0;
    while(fin >> x){
        v[putere(x)]++;
        cnt++;
    }
    if(cnt < n){
        cout << "Nu exista";
        return 0;
    }
    int suma = 0;
    int nr = 1;
    for(int i = 9; i>=0; --i)
			{ suma+=v[i];
        if(suma >=n)
         {    while(i){
                    nr*=2;
                    i--;
								  
                }
					      cout << nr;
									return 0; 
            }
				}
   return 0;
}
------------------
Sortare prin insertie

v=
x=12
v=12
x=7
v=7 12
x=8
v=7 8 12
x=5

i=n;
while(v[i]>x && i>=1)
  {v[i+1]=v[i];
  i--;}
//v[i]<=x
v[i+1]=x;
----------------
MERGE SORT/ interclasare
--------------------

Se dau 2 vectori ordonati crescator si o valoare k
v1 are n valori, v2 are m valori, n=m^2
Care este complexitatea minima a algoritmului care calculeaza valorile a si b cu a+b=k


for(i=1;i<=m;i++)
{ poz=cautbinar(v1,n,k-v2[i])
...
}
m*log2(m^2)===>2*m*log2(m)---> O(mlog(m))
-----------------
Se da un vector ordonat di o valoare x care apare de f multe ori.
Sa se determine nr de aparitii al valorii x
v= 1 2 3 4 4 4 4 4 4 4 4 4 7 8, x=4---> nr=9

##include <bits/stdc++.h>

using namespace std;

int poz_st (int v[], int n, int nr)
{
  int st=1, dr=n, poz=0;
  while(st<=dr)
    {
      int m=(st+dr)/2;
      if(v[m]<nr)
      {
        st=m+1;
      }
      else if(v[m]>nr)
      {
        dr=m-1;
      }
      else
      {poz=m;dr=m-1;}
    }
  return poz;
}

int poz_dr (int v[], int n, int nr)
{
  int st=1, dr=n, poz=0;
  while(st<=dr)
    {
      int m=(st+dr)/2;
      if(v[m]<nr)
      {
        st=m+1;
      }
      else if(v[m]>nr)
      {
        dr=m-1;
      }
      else
      {poz=m; st=m+1;}
    }
  return poz;
}

int main()
{
    int n;
    int x=4;
    int v[]={0,1,2,4,4,4,4,4,4,5};
    cout<<poz_dr(v, 9, x)<<endl;
	 cout<<poz_st(v, 9, x);
   
   return 0;
}

sortare prin DEI--->O(nlog(n))
cautare binara ---> O(log(n))

4 5 6 3 4
4 5 6    3 4
4 5  6   3    4
4  5
  45
------------------

BACKTRACKING
generarea permutarilor/aranjamentelor/combinarilor/elementelor produsului cartezian/anagramelor

Generarea permutarilor
pp. write()-afisam solutia, valid(k)-verifica daca x[1],x[2]..x[k] poate conduce la o permutare

 
230

Backtracking-varianta iterativa

void back()
{ int k=0;
  while(k!=0)
   if(k==n+1) {write();k--;}
   else
    if(x[k]<n)
    { x[k]++;
      if(valid(k)) 
          k++;
    }
    else
     {x[k]=0; k--;}
}

Backtracking recursiv
void back(int k)
{
   if(k==n+1) {write();return;}
   else
    for(int i=1;i<=n;i++)
    { x[k]=i;
      if(valid(k)) back(k+1);
    }
}
Backtracking recursiv- optimizat
int used[11];
void back(int k)
{
   if(k==n+1) {write();return;}
   else
    for(int i=1;i<=n;i++)
      if(!used[i]) 
      { x[k]=i;used[i]=1;
        back(k+1);
        used[i]=0;
       }
}

in main()...back(1);
    }
bacuri--- > probleme III (siruri si eficienta) din 2016-2018!!

https://www.modinfo.ro/admitere/buc/septembrie2022/INFORMATICA-v1.pdf
